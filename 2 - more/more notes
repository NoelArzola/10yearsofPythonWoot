Formatting and linting

Formatting
- [PEP 8](https://pep8.org/) is a set of coding conventions for Python code
- [Docstring](https://www.python.org/dev/peps/pep-0257/) is the standard for documenting a module, function, class or method definition

Linting

Linting helps you identify formatting and convention issues in your Python code

- [Pylint](https://www.pylint.org/) Pylint is a linter for Python to help enforce coding standards and check for errors in Python code
- [Linting Python in Visual Studio Code](https://code.visualstudio.com/docs/python/linting) will show you how to enable litners in VS Code
- [Type hints](https://docs.python.org/3/library/typing.html) allow some interactive development environments and linters to enforce types

Good code:
def print_hello(name: str) -> str: *type hint*
    """ Doc strings =)
    Greets the user by name

	Parameters:
		name (str): The name of the user
	Returns:
		str: The greeting
	""" end Doc strings =)
	print('Hello, ' + name)

Bad code:
x = 12
if x == 24:
 print('Is valid')
else:
    print("Not valid")

def helper(name='sample'):
 pass

def another(name = 'sample'):
         pass

(Woof. haha)

Lambdas

Sort - Can automatically handle primitve types and strings. If we need to do anything complex we need to tell sort how to sort. The key parameter allows you to pass in a function to call for each list element before it compares items for sorting.

A [lambda](https://www.w3schools.com/python/python_lambda.asp) function is a small anonymous function. It can take any number of arguments but can only execute one expression.

Check the demo ;-)

Classes
Classes define data structures and behavior, Classes allow you to group data and functionality together.
Classes are the noun and properties are the adjectives. Methods would be the verbs.

why use? Classes create reusable components and group data & operations together

Creating a class (PascalCasing):
class Presenter():
    def __init__(self, name):
		# Constructor
		self.name = name
		def say_hello(self)
		# method
		print('Hello, ' + self.name)

The only difference between a Constructor and a normal function is when it gets called. Constructor is called when we look to create a brand new instance (of Presenter in this example).

When we use a field think how everyone is going to be able to use and change it. EVERYTHING is public.
Conventions for suggesting accessilibity:
_ means avoid unless you really know what you're doing 
__ means DO NOT USE

Adding properties (control accessilibity better, limit what someone else can do to the class)

Property gives field style access but uses methods behinds the scenes.

class Presenter():
      def __init__(self,name):
			# Constructor
			self.name = name

			@property # getter x = presenter name
			def name(self):
			      return self.__name
			@name.setter # presenter.name = 'Noel'
			def name(self, value):
			      # validation helper
					  self.__name = value

Inheritance
Creates an "is a" relationship
	Student is a person
	SqlConnection is a DatabaseConnection
	MySqlConnection is a DatabaseConnection

Composition (with properties) creates a "has a" relationship
	Student has a Class
	DatabaseConnection has a ConnectionString

Allows you to define a class that inherits all the methods and properties from another class. The parent or base class is the class being inherited from. The child or derived class is the class that inherits from another class.

All methonds are "virtual" - can override or redefine their behavior
Keyword super to access parent class
  Constructor 
	Properties in Methods
Must always call parent constructor

Inheriting from a class:
class Person:
    def __init__(self, name):
		    self.name = name
		def say_hello(self):
		    print('Hello, ' + self.name)

class Student(Person): #where we inherit (Student is a Person)
    def __init__(self, name, school): # name comes from person
		    super().__init__(name) # call parent connstructor
				self.school = school
		def sing_school_song(self):
		    print('Ode to ' + self.school)

Using a derived class:
student = Student('Noel', 'Fredonia')
student.say_hello()
student.sing_school_song()
# What are you?
print(isinstance(student, Student))
print(isinstance(student, Person))
print(issubclass(Student, Person))

Overriding __str__
Every single class you create automotically inherits from Object. Because of that we can always override that behavior.

	class Person:
			def __init__(self, name):
					self.name = name
			def say_hello(self):
					print('Hello, ', + self.name)
			def __str__(self):
					return self.name
	presenter = Presenter('Noel')
	print(presenter)

	When we override a function it's not automatically going to call the base Parent or base Class, we have to tell it to do that.

YAGNI - You aren't gonna need it
*Don't add functionality to the code until you actually need it*

Mixins (Multiple Inheritance) *******

Python allows you to inherit from multiple classes. While the technical term for this is multiple inheritance, many developers refer to the use of more than one base class adding a mixin. These are commonly used in frameworks such as [Django](https://www.djangoproject.com).

  Inherit from multiple Classes
	A little controversial
	--can get messy quickly
	--many modern languages only support single Inheritance
	Uses
	--enable fuctionalality for frameworks such as Django
	--streamline repititious operations

Managing the file system!

Managing files
  All the common operations are built into Python 
	Static or classless
	 os.path
	   Old style
	Class based
	Path from pathlib library
	Python 3.6 or higher
	Better performance (as it can avoid calls to the OS)

Working with paths
Grab the library: from pathlib import Path
See where you are: cwd = Path.cwd()
                   print(cwd)
Combine parts to create full path and file name: new_file = Path.joinpath(cwd, 'new_file.txt')
                                                 print(new_file)
Does this exist? print(new_file.exists())

Working with directories
from pathlib impart Path
cwd = Path.cwd()

Get the parent directory: parent = cwd.parent
Is this a directory? print(pranet.is_dir())
Is this a file? print(parent.is_file())
List child directories: 
    for child in parent.iterdir():
		    if child.is_dir():
				    print(child)

Working with files
from pathlib import Path
cmd = Path.cwd()
demo_file = Path(Path.joinpath(cwd, 'demo.txt'))
Get the file name: print(demo.file.name)
Get the extension: print(demo_file.suffix)
Get the folder: print(demo_file.parent.name)
Get the size: print(demo_file.stat().st_size)

Opening a file
stream = open(file_name, mode, buffer_size)

Modes:
r - Read (default)
w - Truncate and write
a - Append if file exists
x - Write, fail if file exists
+ - Updating (read/write)

t - Text (default)
b - Binary

Reading from a file:
stream = open('demo.txt')

print(stream.readable()) --Can we read?
print(steram.read(1)) --Read the first character
print(stream.readline()) -- Read a line
stream.close() --close the stream

Writing to a file:
stream = open('output.txt, 'wt') --write text
stream.write('H') --write a single string
stream.writelines(['ello', ' ', 'world' ]) --write multiple strings
stream.write('\n') --write a new line
names = ['Susan', 'Noel'] --create a list of strings
stream.writelines(names) --write list of strings
stream.close() -- close the stream (and flush the data)

Managing the stream:
stream = open('output.txt', 'wt')
stream.write('demo!')
stream.seek(0) --put the cursor back at the start
stream.write('cool')
stream.flush() write the data to file
stream.close() flush and close the stream